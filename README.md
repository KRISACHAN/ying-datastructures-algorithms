# 数据结构与算法JavaScript

[TOC]

## 1. 数组(Array)

### **标准定义**

 一个存储元素的线性集合（collection），元素可以通过索引来任意存取，索引通常是数字，用来计算元素之间存储位置的偏移量。

### **JS里**

 JavaScript 中的数组是一种特殊的对象，用来表示偏移量的索引是该对象的属性，索引可能是整数。然而，这些数字索引在内部被转换为字符串类型，这是因为JavaScript 对象中的属性名必须是字符串。数组在JavaScript 中只是一种特殊的对象，所以效率上不如其他语言中的数组高。

## 2. 列表(Lists)

### **概念**

列表是一组有序的数据。每个列表中的数据项称为元素。在JavaScript 中，列表中的元素可以是任意数据类型。列表中可以保存多少元素并没有事先限定，实际使用时元素的数量受到程序内存的限制。不包含任何元素的列表称为空列表。

### **抽象数据类型定义**

| 方法（或属性）         | 说明                |
| --------------- | ----------------- |
| listSize（属性）    | 列表的元素个数           |
| pos（ 属性）        | 列表的当前位置           |
| length（ 属性）     | 返回列表中元素的个数        |
| clear（ 方法）      | 清空列表中的所有元素        |
| toString（ 方法）   | 返回列表的字符串形式        |
| getElement（ 方法） | 返回当前位置的元素         |
| insert（ 方法）     | 在现有元素后插入新元素       |
| append（ 方法）     | 在列表的末尾添加新元素       |
| remove（ 方法）     | 从列表中删除元素          |
| front（ 方法）      | 将列表的当前位置设移动到第一个元素 |
| end（ 方法）        | 将列表的当前位置移动到最后一个元素 |
| prev（方法）        | 将当前位置后移一位         |
| next（ 方法）       | 将当前位置前移一位         |
| currPos（ 方法）    | 返回列表的当前位置         |
| moveTo（方法）      | 将当前位置移动到指定位置      |

## 3. 栈(Stack)

### **定义** 

栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。栈被称为一种后入先出（LIFO，last-in-first-out）的数据结构。

### **栈方法**

| 方法（或属性）  | 说明      |
| -------- | ------- |
| push（方法） | 入栈      |
| pop（方法）  | 出栈      |
| peek（方法） | 只返回栈顶元素 |

## 4. 队列(Queue)

### **定义**

 队列是一种列表，不同的是队列只能在队尾插入元素，在队首删除元素。队列用于存储按顺序排列的数据，先进先出（First-In-First-Out，FIFO）。

### **列队操作**

| 方法（或属性）   | 说明          |
| --------- | ----------- |
| peek（方法）  | 返回队头元素      |
| clear（方法） | 清空队列中的所有元素  |
| push（方法）  | 在数组末尾加入元素   |
| shift（方法） | 可删除数组的第一个元素 |

## 5. 链表(Linked list)

### **定义**

链表是由一组节点组成的集合。每个节点都使用一个对象的引用指向它的后继。指向另一个节点的引用叫做链。链表的尾元素指向一个null 节点。最前面有一个特殊节点，叫做头节点。

### **链表方法**

| 方法（或属性）        | 说明              |
| -------------- | --------------- |
| insert（方法）     | 插入节点            |
| remove（方法）     | 删除节点            |
| display（方法）    | 显示列表元素          |
| advance(n)（方法） | 在链表中向前移动n 个节点   |
| back(n)（方法）    | 在双向链表中向后移动n 个节点 |
| show()（方法）     | 只显示当前节点         |

### **双向链表**

### **出现原因**

 尽管从链表的头节点遍历到尾节点很简单，但反过来，从后向前遍历则没那么简单。

### **原理**

通过给Node 对象增加一个属性，该属性存储指向前驱节点的链接，这样就容易多了。此时向链表插入一个节点需要更多的工作，我们需要指出该节点正确的前驱和后继。但是在从链表中删除节点时，效率提高了，不需要再查找待删除节点的前驱节点了。


### **循环列表**

### **定义**

循环链表和单向链表相似，节点类型都是一样的。唯一的区别是，在创建循环链表时，让其头节点的next 属性指向它本身,这种行为会传导至链表中的每个节点，使得每个节点的next 属性都指向链表的头节点。换句话说，链表的尾节点指向头节点，形成了一个循环链表。

### **注意**

 一些列表方法需要修改才能工作正常。比如，display() 就需要修改，原来的方式在循环链表里会陷入死循环。while 循环的循环条件需要修改，需要检查头节点，当循环到头节点时退出循环。

## 6. 字典(Dictionary)

### **定义**

字典是一种以键- 值对形式存储数据的数据结构，JavaScript 的Object 类就是以字典的形式设计的。

### **方法**

| 方法（或属性）     | 说明        |
| ----------- | --------- |
| add（方法）     | 添加键- 值对   |
| find（方法）    | 查找键- 值对   |
| remove（方法）  | 移除键- 值对   |
| showAll（方法） | 展示所有键- 值对 |
| count（方法）   | 查找键- 值对数量 |
| clear（方法）   | 清除键- 值对   |
| sort（方法）    | 键- 值对排序   |

## 7. 散列(Hash)

### **定义**

把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。

### **碰撞**

即使使用一个高效的散列函数，仍然存在将两个键映射成同一个值的可能，这种现象称为碰撞（collision）。

### **大小限制**

数组长度应该是一个质数。

### **方法**

| 方法（或属性）        | 说明                                       |
| -------------- | ---------------------------------------- |
| simpleHash（方法） | 数据存储到散列化算法。                              |
| showDistro（方法） | 展示数据。                                    |
| put（方法）        | 将键值散列化后，将数据存储到散列化后的键值对应在数组中的位置上。         |
| get（方法）        | 读取存储在散列表中的数据，需要对键值进行散列化，然后才能知道数据到底存储在数组的什么位置。 |

### **碰撞处理**

**1. 开链法**

**定义**

当碰撞发生时，我们仍然希望将键存储到通过散列算法产生的索引位置上，但实际上，不可能将多份数据存储到一个数组单元中。开链法是指实现散列表的底层数组中，每个数组元素又是一个新的数据结构，比如另一个数组，这样就能存储多个键了。使用这种技术，即使两个键散列后的值相同，依然被保存在同样的位置，只不过它们在第二个数组中的位置不一样罢了。

**方法**

 在创建存储散列过的键值的数组时，通过调用一个函数创建一个新的空数组，然后将该数组赋给散列表里的每个数组元素。这样就创建了一个二维数组。

**2. 线性探测法**

**定义**

当发生碰撞时，线性探测法检查散列表中的下一个位置是否为空。如果为空，
就将数据存入该位置；如果不为空，则继续检查下一个位置，直到找到一个空的位置为
止。该技术是基于这样一个事实：每个散列表都会有很多空的单元格，可以使用它们来存
储数据。

**3. 方法选择公式**

如果数组的大小是待存储数据个数的1.5 倍，那么使用开链法；如果数组的大小是待存储数据的两倍及两倍以上时，那么使用线性探测法。

## 8. 集合(Set)

### **定义**

1. 不包含任何成员的集合称为空集，全集则是包含一切可能成员的集合。

2. 如果两个集合的成员完全相同，则称两个集合相等。

3. 如果一个集合中所有的成员都属于另外一个集合，则前一集合称为后一集合的子集。

### **操作**

1. **并集**

    将两个集合中的成员进行合并，得到一个新集合。

2. **交集**

    两个集合中共同存在的成员组成一个新的集合。

3. **补集**

   属于一个集合而不属于另一个集合的成员组成的集合。

### **实现**

| 方法（或属性）        | 说明                |
| -------------- | ----------------- |
| add（方法）        | 添加数据              |
| remove（方法）     | 移除数据              |
| size（属性）       | 返回集合长度            |
| union（方法）      | 并集操作              |
| intersect（方法）  | 交集                |
| subset（方法）     | 判断一个集合是否是另一个集合的子集 |
| difference（方法） | 补集                |
| show（方法）       | 展示集合              |

## 9. 二叉树和二叉查找树 (Binary Search Tree)

### **定义**

1. **树**

    树是一种非线性的数据结构，以分层的方式存储数据。树由一组以边连接的节点组成。每个节点都有一个与之相关的值，该值有时被称为键。

2. **二叉树**

   二叉树是一种特殊的树，它的子节点个数不超过两个。

### **实现**

| 说明                                       | 方法（或属性）        |
| ---------------------------------------- | -------------- |
| 一个表示二叉查找树根节点的Node 对象。该类的构造函数将根节点初始化为null，以此创建一个空节点。 | Node（对象）       |
| 表示二叉查找树。                                 | BST（类）         |
| 左二叉树节点。                                  | left（方法）       |
| 右二叉树节点。                                  | right（方法）      |
| 展示数据。                                    | show（方法）       |
| 查找给定值                                    | search（方法）     |
| 找最小值                                     | getMin（方法）     |
| 查找最大值                                    | getMax（方法）     |
| 删除数据                                     | removeNode（方法） |
| 简单地接受待删除数据，调用removeNode()删除它，后者才是完成主要工作的方法。 | remove（方法）     |
| 更新BST类节点                                 | update（方法）     |

### **遍历方式**

1. **中序**

   遍历按照节点上的键值，以升序访问BST类上的所有节点。

2. **先序**

    先序遍历先访问根节点，然后以同样方式访问左子树和右子树。

3. **后序**

   遍历先访问叶子节点，从左子树到右子树，再到根节点。

## 10. 图

### **定义**

1. **图**

   由边的集合及顶点的集合组成。

2. **顶点**

    图的节点。顶点也有权重，也称为成本。

3. **边**

   连接顶点的就是边。

4. **有向图**

   如果一个图的顶点对是有序的，则可以称之为有向图。计算机程序中用来表明计算方向的流程图就是一个有向图的例子。

5. **无序图**

   如果图是无序的，则称之为无序图，或无向图。

6. **路径**

   图中的一系列顶点构成路径，路径中所有的顶点都由边连接。路径的长度用路径中第一个顶点到最后一个顶点之间边的数量表示。

7. **环**

   由指向自身的顶点组成的路径称为环，环的长度为0。

8. **圈**

    圈是至少有一条边的路径，且路径的第一个顶点和最后一个顶点相同。无论是有向图还是无向图，只要是没有重复边或重复顶点的圈，就是一个简单圈。除了第一个和最后一个顶点以外，路径的其他顶点有重复的圈称为平凡圈。

9. **强连通**

   如果两个顶点之间有路径，那么这两个顶点就是强连通的，反之亦然。如果有向图的所有的顶点都是强连通的，那么这个有向图也是强连通的。

### **实现**

| 方法（或属性）           | 说明                                       |
| ----------------- | ---------------------------------------- |
| Vertex（类）         | 保存顶点和边。                                  |
| label（属性）         | Vertex类数据成员，用于标识顶点。                      |
| wasVisited（属性）    | Vertex类数据成员，表明这个顶点是否被访问过的布尔值。            |
| Graph（类）          | 表示图的类。                                   |
| addEdge(v, w)（方法） | 当调用这个函数并传入顶点A 和B 时，函数会先查找顶点A 的邻接表，将顶点B 添加到列表中，然后再查找顶点B 的邻接表，将顶点A 加入列表。 |
| showGraph（方法）     | 会通过打印所有顶点及其相邻顶点列表的方式来显示图。                |

### **搜索图**

**定义**

确定从一个指定的顶点可以到达其他哪些顶点，这是经常对图执行的操作。图上的这些操作是用搜索算法执行的。在图上可以执行两种基础搜索：深度优先搜索和广度优先搜索。

**方法**

1. **深度优先搜索**

   深度优先搜索包括从一条路径的起始顶点开始追溯，直到到达最后一个顶点，然后回溯，继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止。访问一个没有访问过的顶点，将它标记为已访问，再递归地去访问在初始顶点的邻接表中其他没有访问过的顶点。

2. **广度优先搜索**

   广度优先搜索从第一个顶点开始，尝试访问尽可能靠近它的顶点。本质上，这种搜索在图上是逐层移动的，首先检查最靠近第一个顶点的层，再逐渐向下移动到离起始顶点最远的层。广度优先搜索算法使用了抽象的队列而不是数组来对已访问过的顶点进行排序。

   **工作原因**

   1. 查找与当前顶点相邻的未访问顶点，将其添加到已访问顶点列表及队列中；
   2. 从图中取出下一个顶点v，添加到已访问的顶点列表；
   3. 将所有与v 相邻的未访问顶点添加到队列。

**查找最短路径**

**概述**

图最常见的操作之一就是寻找从一个顶点到另一个顶点的最短路径。

**广度优先搜索对应的最短路径**

在执行广度优先搜索时，会自动查找从一个顶点到另一个相连顶点的最短路径。

**拓扑排序**

**概述**

拓扑排序会对有向图的所有顶点进行排序，使有向边从前面的顶点指向后面的顶点。

**算法**

拓扑排序算法与深度优先搜索类似。不同的是，拓扑排序算法不会立即输出已访问的顶点，而是访问当前顶点邻接表中的所有相邻顶点，直到这个列表穷尽时，才将当前顶点压入栈中。

**实现**

| 方法（或属性）           | 说明                                       |
| ----------------- | ---------------------------------------- |
| topSort（方法）       | 会设置排序进程并调用一个辅助函数topSortHelper()，然后显示排序好的顶点列表。 |
| topSortHelper（方法） | 主要工作是在递归函数topSortHelper() 中完成的。这个函数会将当前顶点标记为已访问，然后递归访问当前顶点邻接表中的每个相邻顶点，标记这些顶点为已访问。最后，将当前顶点压入栈。 |
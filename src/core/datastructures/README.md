# 算法与数据结构 - TS 描述

> -   作者：陈大鱼头
>
> -   GitHub：https://github.com/KRISACHAN
>
> -   说明：本库是以 **`TypeScript`** 为描述语言的算法与数据结构入门仓库的数据结构部分

## 栈（Stack）

> 栈是一种遵从后进先出（LIFO, last-in-first-out）原则的有序集合。
>
> 新添加的或待删除的元素都保存在栈的 同一端，称作栈顶，另一端就叫栈底。
>
> 在栈里，新元素都靠近栈顶，旧元素都接近栈底。

### 核心方法

| 方法             | 描述                                                                          |
| ---------------- | ----------------------------------------------------------------------------- |
| push(element(s)) | 添加一个（或几个）新元素到栈顶。                                              |
| pop()            | 移除栈顶的元素，同时返回被移除的元素。                                        |
| peek()           | 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返 回它）。 |

## 队列（Queue）

> 队列是遵循 FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序集合。
>
> 队列在尾部添加新元素，并从顶部移除元素。
>
> 最新添加的元素必须排在队列的末尾。

### 核心方法

| 方法                | 描述                                             |
| ------------------- | ------------------------------------------------ |
| enqueue(element(s)) | 向队列尾部添加一个（或多个）新的元素。           |
| dequeue()           | 移除队列的第一（即排在队列最前面的）元素并返回。 |
| peek()              | 返回队列中第一个元素。                           |

## 双端队列

> 双端队列（deque，全名 double-ended queue）是一种具有队列和栈性质的抽象数据类型。
>
> 双端队列中的元素可以从两端弹出，
>
> 插入和删除操作限定在队列的两边进行。

### 核心方法

| 方法                 | 描述                                                 |
| -------------------- | ---------------------------------------------------- |
| addFront(element(s)) | 向队列头部插入添加一个（或多个）新的元素。           |
| addBack(element(s))  | 向队列尾部插入添加一个（或多个）新的元素。           |
| peekFront()          | 返回队列中第一个元素。                               |
| peekBack()           | 返回队列中最后一个元素。                             |
| removeFront()        | 移除队列的第一（即排在队列最前面的）元素并返回。     |
| removeBack()         | 移除队列的最后一个（即排在队列最前面的）元素并返回。 |

## 优先队列

> 优先队列（Priority Queue）：带有权重的队列
>
> 优先队列往往用堆来实现。（JS 里可以是数组）

### 核心方法

| 方法                          | 描述                       |
| ----------------------------- | -------------------------- |
| enqueue(element(s), priority) | 向队尾添加一个元素以及权重 |
| dequeue()                     | 删除队首的元素             |
| front()                       | 读取队首                   |
| back()                        | 读取队尾                   |

## 链表（linked list）

> 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。
>
> 每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。

### 核心方法

| 方法                         | 描述                                                   |
| ---------------------------- | ------------------------------------------------------ |
| append(element(s))           | 向链表尾部添加一个新的元素。                           |
| insert(position, element(s)) | 向链表的特定位置插入一个新的元素。                     |
| getAt(position)              | 从链表的特定位置返回元素。                             |
| removeAt(position)           | 从链表的特定位置移除元素。                             |
| indexOf(element(s))          | 返回元素在链表中的索引。如果列表中没有该元素则返回-1。 |
| remove(element(s))           | 从列表中移除一个元素。                                 |

## 双向链表（DoublyLinkedList）

> 双向链表和普通链表的区别在于，在链表中，
>
> 一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的：一个链向下一个元素，
>
> 另一个链向前一个元素，

### 核心方法

| 方法                         | 描述                                                   |
| ---------------------------- | ------------------------------------------------------ |
| append(element(s))           | 向链表添加一个新的元素。                               |
| insert(position, element(s)) | 向链表的特定位置插入一个新的元素。                     |
| getTail()                    | 返回尾部信息。                                         |
| removeAt(position)           | 删除指定位置元素。                                     |
| indexOf(element(s))          | 返回元素在链表中的索引。如果列表中没有该元素则返回-1。 |
| remove(element(s))           | 从列表中移除一个元素。                                 |

## 循环链表（CircularLinkedList）

> 循环链表（CircularLinkedList）：循环链表跟普通链表的区别就是循环链表是头尾相连的

### 核心方法

| 方法                         | 描述                               |
| ---------------------------- | ---------------------------------- |
| append(element(s))           | 向链表尾部添加一个新的元素。       |
| insert(position, element(s)) | 向链表的特定位置插入一个新的元素。 |
| removeAt(position)           | 从链表的特定位置移除元素。         |

## 堆

> 维基百科：
>
> 堆（英语：Heap）：堆是树状结构，给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于）C 的值。
>
> 最小堆（min heap）：若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；
>
> 最大堆（max heap：反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。
>
> 根节点（root node）：在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有母节点（parent node）。
>
> 任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（**堆序性**）。
> 堆总是一棵[完全树](https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91)。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。
> 将根节点最大的堆叫做**最大堆**或**大根堆**，根节点最小的堆叫做**最小堆**或**小根堆**。

### 核心方法

|        操作        |         描述         |
| :----------------: | :------------------: |
| insert(element(s)) | 向堆中插入一个新元素 |
|  find(element(s))  |  在堆中寻找指定元素  |
| remove(element(s)) |  在堆中删除指定元素  |
|       peek()       |       查看堆顶       |
|       poll()       |    将堆尾换到堆头    |

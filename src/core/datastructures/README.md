# 算法与数据结构 - TS 描述

> -   作者：陈大鱼头
>
> -   GitHub：https://github.com/KRISACHAN
>
> -   说明：本库是以 **`TypeScript`** 为描述语言的算法与数据结构入门仓库的数据结构部分

## 栈（Stack）

> 栈是一种遵从后进先出（LIFO, last-in-first-out）原则的有序集合。
>
> 新添加的或待删除的元素都保存在栈的 同一端，称作栈顶，另一端就叫栈底。
>
> 在栈里，新元素都靠近栈顶，旧元素都接近栈底。

### 核心方法

| 方法             | 描述                                                                          |
| ---------------- | ----------------------------------------------------------------------------- |
| push(element(s)) | 添加一个（或几个）新元素到栈顶。                                              |
| pop()            | 移除栈顶的元素，同时返回被移除的元素。                                        |
| peek()           | 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返 回它）。 |

## 队列（Queue）

> 队列是遵循 FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序集合。
>
> 队列在尾部添加新元素，并从顶部移除元素。
>
> 最新添加的元素必须排在队列的末尾。

### 核心方法

| 方法                | 描述                                             |
| ------------------- | ------------------------------------------------ |
| enqueue(element(s)) | 向队列尾部添加一个（或多个）新的元素。           |
| dequeue()           | 移除队列的第一（即排在队列最前面的）元素并返回。 |
| peek()              | 返回队列中第一个元素。                           |

## 双端队列

> 双端队列（deque，全名 double-ended queue）是一种具有队列和栈性质的抽象数据类型。
>
> 双端队列中的元素可以从两端弹出，
>
> 插入和删除操作限定在队列的两边进行。

### 核心方法

| 方法                 | 描述                                                 |
| -------------------- | ---------------------------------------------------- |
| addFront(element(s)) | 向队列头部插入添加一个（或多个）新的元素。           |
| addBack(element(s))  | 向队列尾部插入添加一个（或多个）新的元素。           |
| peekFront()          | 返回队列中第一个元素。                               |
| peekBack()           | 返回队列中最后一个元素。                             |
| removeFront()        | 移除队列的第一（即排在队列最前面的）元素并返回。     |
| removeBack()         | 移除队列的最后一个（即排在队列最前面的）元素并返回。 |

## 优先队列

> 优先队列（Priority Queue）：带有权重的队列
>
> 优先队列往往用堆来实现。（JS 里可以是数组）

### 核心方法

| 方法                          | 描述                       |
| ----------------------------- | -------------------------- |
| enqueue(element(s), priority) | 向队尾添加一个元素以及权重 |
| dequeue()                     | 删除队首的元素             |
| front()                       | 读取队首                   |
| back()                        | 读取队尾                   |

## 链表（linked list）

> 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。
>
> 每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。

### 核心方法

| 方法                         | 描述                                                   |
| ---------------------------- | ------------------------------------------------------ |
| append(element(s))           | 向链表尾部添加一个新的元素。                           |
| insert(position, element(s)) | 向链表的特定位置插入一个新的元素。                     |
| getAt(position)              | 从链表的特定位置返回元素。                             |
| removeAt(position)           | 从链表的特定位置移除元素。                             |
| indexOf(element(s))          | 返回元素在链表中的索引。如果列表中没有该元素则返回-1。 |
| remove(element(s))           | 从列表中移除一个元素。                                 |

## 双向链表（DoublyLinkedList）

> 双向链表和普通链表的区别在于，在链表中，
>
> 一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的：一个链向下一个元素，
>
> 另一个链向前一个元素，

### 核心方法

| 方法                         | 描述                                                   |
| ---------------------------- | ------------------------------------------------------ |
| append(element(s))           | 向链表添加一个新的元素。                               |
| insert(position, element(s)) | 向链表的特定位置插入一个新的元素。                     |
| getTail()                    | 返回尾部信息。                                         |
| removeAt(position)           | 删除指定位置元素。                                     |
| indexOf(element(s))          | 返回元素在链表中的索引。如果列表中没有该元素则返回-1。 |
| remove(element(s))           | 从列表中移除一个元素。                                 |

## 循环链表（CircularLinkedList）

> 循环链表（CircularLinkedList）：循环链表跟普通链表的区别就是循环链表是头尾相连的

### 核心方法

| 方法                         | 描述                               |
| ---------------------------- | ---------------------------------- |
| append(element(s))           | 向链表尾部添加一个新的元素。       |
| insert(position, element(s)) | 向链表的特定位置插入一个新的元素。 |
| removeAt(position)           | 从链表的特定位置移除元素。         |

## 堆

> 维基百科：
>
> 堆（英语：Heap）：堆是树状结构，给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于）C 的值。
>
> 最小堆（min heap）：若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；
>
> 最大堆（max heap：反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。
>
> 根节点（root node）：在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有母节点（parent node）。
>
> 任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（**堆序性**）。
> 堆总是一棵[完全树](https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91)。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。
> 将根节点最大的堆叫做**最大堆**或**大根堆**，根节点最小的堆叫做**最小堆**或**小根堆**。

### 核心方法

|        操作        |         描述         |
| :----------------: | :------------------: |
| insert(element(s)) | 向堆中插入一个新元素 |
|  find(element(s))  |  在堆中寻找指定元素  |
| remove(element(s)) |  在堆中删除指定元素  |
|       peek()       |       查看堆顶       |
|       poll()       |    将堆尾换到堆头    |

## 二叉查找树（Binary Search Tree）

> 二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。
>
> 二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值， 在右侧节点存储（比父节点）大（或者等于）的值。上一节的图中就展现了一棵二叉搜索树。

### 核心方法

|       操作        |                                  描述                                   |
| :---------------: | :---------------------------------------------------------------------: |
|    insert(key)    |                         向树中插入一个新的键。                          |
|    search(key)    | 在树中查找一个键，如果节点存在，则返回 true；如果不存在，则返回 false。 |
|  inOrderTraverse  |                     通过中序遍历方式遍历所有节点。                      |
| preOrderTraverse  |                     通过先序遍历方式遍历所有节点。                      |
| postOrderTraverse |                     通过后序遍历方式遍历所有节点。                      |
|        min        |                          返回树中最小的值/键。                          |
|        max        |                          返回树中最大的值/键。                          |
|    remove(key)    |                           从树中移除某个键。                            |

### 其他

* 满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。
* 完全二叉树：对于深度为 K 的，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 K 的满二叉树中编号从 1 至 n 的结点一一对应时称之为完全二叉树。

## AVL树（Adelson VelskiiLandi Tree）

> AVL树是最早被发明的自平衡二叉查找树。
>
> 在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。
>
> 查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log n)。
>
> 增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。

### AVL旋转方法

| 操作                   | 描述                        |
| ---------------------- | --------------------------- |
| rotationLL(node)       | 左 - 左（LL）：向右的单旋转 |
| rotationRR(node)       | 右 - 右（RR）：向左的单旋转 |
| rotationLR(node)       | 左 - 右（LR）：向右的双旋转 |
| rotationRL(node)       | 右 - 左（RL）：向左的双旋转 |
| getBalanceFactor(node) | 获取平衡系数                |



## 红黑树（Red Black Tree）

> 红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。
>
> 红黑树是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。
>
> 红黑树是一种特化的AVL树（平衡二叉树），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。

### 性质

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是null节点）。
4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

这些约束确保了红黑树的关键特性： **从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。**

## 字典（Dictionary）

> 维基百科：
> 
> 在计算机科学中，关联数组（英语：Associative Array），又称映射（Map）、字典（Dictionary）是一个抽象的数据结构，它包含着类似于（键，值）的有序对。
> 
> 一个关联数组中的有序对可以重复（如C++中的multimap）也可以不重复（如C++中的map）。
>
> 这种数据结构包含以下几种常见的操作：
> 
> * 向关联数组添加配对
> * 从关联数组内删除配对
> * 修改关联数组内的配对
> * 根据已知的键寻找配对

### 核心方法

|      操作      |                           描述                            |
| :------------: | :-------------------------------------------------------: |
| set(key,value) |                    向字典中添加新元素                     |
|  remove(key)   |        通过使用键值来从字典中移除键值对应的数据值         |
|    has(key)    | 如果某个键值存在于这个字典中，则返回true，反之则返回false |
|    get(key)    |               通过键值查找特定的数值并返回                |
|    clear()     |              将这个字典中的所有元素全部删除               |
|     size()     |     返回字典所包含元素的数量。与数组的length属性类似      |
|     keys()     |           将字典所包含的所有键名以数组形式返回            |
|    values()    |           将字典所包含的所有数值以数组形式返回            |


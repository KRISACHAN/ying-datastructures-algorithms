# 算法与数据结构 - TS 描述

> -   作者：陈大鱼头
>
> -   GitHub：https://github.com/KRISACHAN
>
> -   说明：本库是以 **`TypeScript`** 为描述语言的算法与数据结构入门仓库的数据结构部分

## 栈（Stack）

> 栈是一种遵从后进先出（LIFO, last-in-first-out）原则的有序集合。
>
> 新添加的或待删除的元素都保存在栈的 同一端，称作栈顶，另一端就叫栈底。
>
> 在栈里，新元素都靠近栈顶，旧元素都接近栈底。

### 核心方法

| 方法             | 描述                                                                          |
| ---------------- | ----------------------------------------------------------------------------- |
| push(element(s)) | 添加一个（或几个）新元素到栈顶。                                              |
| pop()            | 移除栈顶的元素，同时返回被移除的元素。                                        |
| peek()           | 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返 回它）。 |

## 队列（Queue）

> 队列是遵循 FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序集合。
>
> 队列在尾部添加新元素，并从顶部移除元素。
>
> 最新添加的元素必须排在队列的末尾。

### 核心方法

| 方法                | 描述                                             |
| ------------------- | ------------------------------------------------ |
| enqueue(element(s)) | 向队列尾部添加一个（或多个）新的元素。           |
| dequeue()           | 移除队列的第一（即排在队列最前面的）元素并返回。 |
| peek()              | 返回队列中第一个元素。                           |

## 双端队列

> 双端队列（deque，全名 double-ended queue）是一种具有队列和栈性质的抽象数据类型。
>
> 双端队列中的元素可以从两端弹出，
>
> 插入和删除操作限定在队列的两边进行。

### 核心方法

| 方法                 | 描述                                                 |
| -------------------- | ---------------------------------------------------- |
| addFront(element(s)) | 向队列头部插入添加一个（或多个）新的元素。           |
| addBack(element(s))  | 向队列尾部插入添加一个（或多个）新的元素。           |
| peekFront()          | 返回队列中第一个元素。                               |
| peekBack()           | 返回队列中最后一个元素。                             |
| removeFront()        | 移除队列的第一（即排在队列最前面的）元素并返回。     |
| removeBack()         | 移除队列的最后一个（即排在队列最前面的）元素并返回。 |

## 优先队列

> 优先队列（Priority Queue）：带有权重的队列
>
> 优先队列往往用堆来实现。（JS 里可以是数组）

### 核心方法

| 方法                          | 描述                       |
| ----------------------------- | -------------------------- |
| enqueue(element(s), priority) | 向队尾添加一个元素以及权重 |
| dequeue()                     | 删除队首的元素             |
| front()                       | 读取队首                   |
| back()                        | 读取队尾                   |

## 链表（linked list）

> 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。
>
> 每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。

### 核心方法

| 方法                         | 描述                                                   |
| ---------------------------- | ------------------------------------------------------ |
| append(element(s))           | 向链表尾部添加一个新的元素。                           |
| insert(position, element(s)) | 向链表的特定位置插入一个新的元素。                     |
| getAt(position)              | 从链表的特定位置返回元素。                             |
| removeAt(position)           | 从链表的特定位置移除元素。                             |
| indexOf(element(s))          | 返回元素在链表中的索引。如果列表中没有该元素则返回-1。 |
| remove(element(s))           | 从列表中移除一个元素。                                 |

## 双向链表（DoublyLinkedList）

> 双向链表和普通链表的区别在于，在链表中，
>
> 一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的：一个链向下一个元素，
>
> 另一个链向前一个元素，

### 核心方法

| 方法                         | 描述                                                   |
| ---------------------------- | ------------------------------------------------------ |
| append(element(s))           | 向链表添加一个新的元素。                               |
| insert(position, element(s)) | 向链表的特定位置插入一个新的元素。                     |
| getTail()                    | 返回尾部信息。                                         |
| removeAt(position)           | 删除指定位置元素。                                     |
| indexOf(element(s))          | 返回元素在链表中的索引。如果列表中没有该元素则返回-1。 |
| remove(element(s))           | 从列表中移除一个元素。                                 |

## 循环链表（CircularLinkedList）

> 循环链表（CircularLinkedList）：循环链表跟普通链表的区别就是循环链表是头尾相连的

### 核心方法

| 方法                         | 描述                               |
| ---------------------------- | ---------------------------------- |
| append(element(s))           | 向链表尾部添加一个新的元素。       |
| insert(position, element(s)) | 向链表的特定位置插入一个新的元素。 |
| removeAt(position)           | 从链表的特定位置移除元素。         |

## 堆

> 维基百科：
>
> 堆（英语：Heap）：堆是树状结构，给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于）C 的值。
>
> 最小堆（min heap）：若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；
>
> 最大堆（max heap：反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。
>
> 根节点（root node）：在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有母节点（parent node）。
>
> 任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（**堆序性**）。
> 堆总是一棵[完全树](https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91)。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。
> 将根节点最大的堆叫做**最大堆**或**大根堆**，根节点最小的堆叫做**最小堆**或**小根堆**。

### 核心方法

|        操作        |         描述         |
| :----------------: | :------------------: |
| insert(element(s)) | 向堆中插入一个新元素 |
|  find(element(s))  |  在堆中寻找指定元素  |
| remove(element(s)) |  在堆中删除指定元素  |
|       peek()       |       查看堆顶       |
|       poll()       |    将堆尾换到堆头    |

## 二叉查找树（Binary Search Tree）

> 二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。
>
> 二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值， 在右侧节点存储（比父节点）大（或者等于）的值。上一节的图中就展现了一棵二叉搜索树。

### 核心方法

|       操作        |                                  描述                                   |
| :---------------: | :---------------------------------------------------------------------: |
|    insert(key)    |                         向树中插入一个新的键。                          |
|    search(key)    | 在树中查找一个键，如果节点存在，则返回 true；如果不存在，则返回 false。 |
|  inOrderTraverse  |                     通过中序遍历方式遍历所有节点。                      |
| preOrderTraverse  |                     通过先序遍历方式遍历所有节点。                      |
| postOrderTraverse |                     通过后序遍历方式遍历所有节点。                      |
|        min        |                          返回树中最小的值/键。                          |
|        max        |                          返回树中最大的值/键。                          |
|    remove(key)    |                           从树中移除某个键。                            |

### 其他

* 满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。
* 完全二叉树：对于深度为 K 的，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 K 的满二叉树中编号从 1 至 n 的结点一一对应时称之为完全二叉树。

## AVL树（Adelson VelskiiLandi Tree）

> AVL树是最早被发明的自平衡二叉查找树。
>
> 在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。
>
> 查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log n)。
>
> 增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。

### AVL旋转方法

| 操作                   | 描述                        |
| ---------------------- | --------------------------- |
| rotationLL(node)       | 左 - 左（LL）：向右的单旋转 |
| rotationRR(node)       | 右 - 右（RR）：向左的单旋转 |
| rotationLR(node)       | 左 - 右（LR）：向右的双旋转 |
| rotationRL(node)       | 右 - 左（RL）：向左的双旋转 |
| getBalanceFactor(node) | 获取平衡系数                |



## 红黑树（Red Black Tree）

> 红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。
>
> 红黑树是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。
>
> 红黑树是一种特化的AVL树（平衡二叉树），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。

### 性质

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是null节点）。
4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

这些约束确保了红黑树的关键特性： **从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。**

## 字典（Dictionary）

> 维基百科：
> 
> 在计算机科学中，关联数组（英语：Associative Array），又称映射（Map）、字典（Dictionary）是一个抽象的数据结构，它包含着类似于（键，值）的有序对。
> 
> 一个关联数组中的有序对可以重复（如C++中的multimap）也可以不重复（如C++中的map）。
>
> 这种数据结构包含以下几种常见的操作：
> 
> * 向关联数组添加配对
> * 从关联数组内删除配对
> * 修改关联数组内的配对
> * 根据已知的键寻找配对

### 核心方法

|      操作      |                           描述                            |
| :------------: | :-------------------------------------------------------: |
| set(key,value) |                    向字典中添加新元素                     |
|  remove(key)   |        通过使用键值来从字典中移除键值对应的数据值         |
|    has(key)    | 如果某个键值存在于这个字典中，则返回true，反之则返回false |
|    get(key)    |               通过键值查找特定的数值并返回                |
|    clear()     |              将这个字典中的所有元素全部删除               |
|     size()     |     返回字典所包含元素的数量。与数组的length属性类似      |
|     keys()     |           将字典所包含的所有键名以数组形式返回            |
|    values()    |           将字典所包含的所有数值以数组形式返回            |



## 散列表（HashTable）

> [维基百科](https://zh.wikipedia.org/wiki/哈希表)
>
> 散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。
>
> 散列算法的作用是尽可能快地在数据结构中找到一个值。

### 基本概念

* 若关键字为**k**，则其值存放在**f(k)**的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系**f**为散列函数，按这个思想建立的表为散列表。
* 对不同的关键字可能得到同一散列地址，即**k1****≠k2**，而**f(k1)=f(k2)**，这种现象称为冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数**f(k)**和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。
* 若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。

### 常用方法

* 直接寻址法：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。
* 数字分析法：分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。
* 平方取中法：当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。
* 折叠法：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。
* 随机数法：选择一随机函数，取关键字的随机值作为散列地址，即H(key)=random(key)其中random为随机函数,通常用于关键字长度不等的场合。
* 除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p,p<=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。+9

### 处理冲突

* 开放寻址法：Hi=(H(key) + di) MOD m,i=1,2，…，k(k<=m-1），其中H(key）为散列函数，m为散列表长，di为增量序列，可有下列三种取法：
  1. di=1,2,3，…，m-1，称线性探测再散列；
  2. di=1^2,-1^2,2^2,-2^2，⑶^2，…，±（k)^2,(k<=m/2）称二次探测再散列；
  3. di=伪随机数序列，称伪随机探测再散列。
* 再散列法：Hi=RHi(key),i=1,2，…，k RHi均是不同的散列函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。
* 链地址法（拉链法）
* 建立一个公共溢出区

### 核心方法

| 操作           | 描述                                     |
| -------------- | ---------------------------------------- |
| put(key,value) | 向散列表增加一个新的项（也能更新散列表） |
| remove(key)    | 根据键值从散列表中移除值                 |
| get(key)       | 返回根据键值检索到的特定的值             |

## 图（Graph）

> 图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。学习图是重要的，因为任 何二元关系都可以用图来表示。

### 概念

一个图G = (V, E)由以下元素组成

 V：一组顶点 

 E：一组边，连接V中的顶点

相邻顶点：由一条边连接在一起的顶点

一个顶点的度：其相邻顶点的数量

路径：顶点v1, v2,…,vk的一个连续序列，其中vi和vi+1是相邻的

简单路径：求不包含重复的顶点

无环：不存在环

连 通：每两个顶点间都存在路径

强连通：每两个顶点间在双向上都存在路径

稀疏图：不是强连通的图

邻接表：由图中每个顶点的相邻顶 点列表所组成（存在好几种方式来表示这种数据结构）

加权：带有权重

有向图：边没有方向的图

无向图：边有方向的图

### 核心方法

| 操作          | 描述                   |
| ------------- | ---------------------- |
| aaddVertex(v) | 向图中添加一个新的顶点 |
| addEdge(a, b) | 添加顶点之间的边       |

